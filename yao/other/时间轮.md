# 时间轮

## 为什么要使用时间轮

例如：游戏里面每个Player身上有很多buffs,在每一个tick（最小时间段）都要去检查buff里面的每一个buff是不是过期，产生的效果如何，造成在每个tick里面都去遍历一个长list，明显很不好，所以



分层时间轮模型

1.时钟原理说明：
1.1. 初始化一个三层时间轮:秒刻盘：0~59个SecList, 分刻盘：0~59个MinList, 时刻盘：0~12个HourList;
1.2. SecTick由外界推动,每跳一轮(60格),SecTick复位至0,同时MinTick跳1格;
1.3. 同理MinTick每跳一轮(60格),MinTick复位至0,同时HourTick跳1格;
1.4. 最高层：HourTick跳一轮(12格）,HourTick复位至0，一个时间轮完整周期完成.
2.事件原理说明：
2.1. 设置时间为TimeOut的事件时,根据TimeOut算出发生此事件时刻的指针位置{TriggerHour,TriggerMin,TriggerSec};
2.2. 用{TriggerHour,TriggerMin,TriggerSec}与当前指针{NowHour,NowMin,NowSec}对比得出事件存放在哪一个指针(Tick);
2.3. 所有层的指针每跳到下一格(Tick01)都会触发格子的事件列表,处理每一个事件Event01：
2.3.1 根据事件Event01的剩余TimeOut算出Event01应该存在上一层(跳得更快)层的位置Pos;
2.3.2 把事件更新到新的Pos(更新TimeOut);
2.3.3 重复处理完Tick01里面所有的事件;
2.3.4 清空Tick01的事件;
2.3.5 最底层(跳最快)层所有的事件遇到指针Tick都会立即执行;





### Issues

- 槽的数量是有限的（也许不同的系统会有不同的限制），比如：你可以在Figure11.13非常明显地看出来：最大的可处理长度(总槽度)是350ms,当要安装一个400ms的事件时怎么办？这个会引起时间轮溢出，为了解决这个问题：一种方法就是禁止超过范围的事件安装，另一个更好的方法：把这些溢出的事件放在一个统一的事件缓冲(event buffer)里面，等转盘转到下一刻度时就从buffer中取出符合范围的事件，这样这些事件也可以被处理了

- 这个时间轮的精度，试想一下：当tick指到time wheel 到开始指向下一个时间刻度前，如又安装一个150ms的事件，那么这个事件是安装在+150ms，还是在+200呢？按平均来讲，出错的概率均等的情况下，那么这个出错可能会延迟或提前最小刻度的一半，在这里就是50ms/2=25ms.

- 非常重要的问题：关于callbacks的安装.理论上，每一个Callback都应该在时间过期时同时发生，但是在现实中，这是不可能的，每一个Callback的工作状态都不可预测，因此，执行的每一个callback的长度也不可预测，导致没有方法可以保证一个在很长列表后面的callback会被马上执行，这个问题是不合需求的，不能引放到系统里面

  

## 资料

[时间轮](https://www.cnblogs.com/zhongwencool/p/timing_wheel.html)

