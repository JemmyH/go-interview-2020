

[toc]

# 关系型数据库

## 关系数据库设计的三大范式

- 第一范式：保证每一个字段应该保证不可拆分，确保每个字段的原子性
- 第二范式：在保证第一范式的前提下，所有字段都必须依赖主键
- 第三范式：在保证第二范式的前提下，所有字段都必须直接依赖主键，而不是间接依赖

### 反范式

因为范式的目标是消除冗余，而造成了查询需要连接多张表增加了查询的复杂性与降低数据库性能。这是空间与时间的问题。而在实际场景中

一般是采取使用空间换取时间，进行适当的数据冗余来提高查询效率

冗余字段的规范：

- 不是频繁修改的字段
- 不能是text或者比较长的varchar

### 扩展阅读

[数据库设计三大范式](https://blog.csdn.net/dosthing/article/details/87954213)







## 索引

### 索引是什么，索引的优缺点

索引是数据库一种快速查询的机制

- 优点
  - 提高查询效率
- 缺点
  - 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加
  - 当数据量过大时，索引所占的空间越大

### 索引

mysql 的索引类型一般分为hash索引与B+树



#### hash索引

hash索引因为基于`哈希冲突` 的特性，使用场景如下

- 适合等值查询，不适合范围查询
- 并且值需要尽量保证不重复，不然容易造成hash冲突
  

#### B+树索引

##### 为什么mysql使用b+树？ [ TODO ]

- B+树的查询效率更加稳定,他能保证不管是插入还是查询都是在一个恒定时间内。不会造成太大的波动



##### 10亿数据查询一条记录最多需要几次磁盘访问？

B+树，可以把10亿个键值（指向10亿行记录的指针）保存在第3，4或者5层的高度上，所以每次对于10亿个键的搜索都进行3，4或者5次磁盘访问，大大减少了I/O次数。



#### MySQL 覆盖索引、最左前缀原则、索引下推

[mysql索引篇之覆盖索引、联合索引、索引下推](https://www.jianshu.com/p/bdc9e57ccf8b)



#### 索引覆盖 

查询的数据在索引树中可以找到,不需要回到数据树中去查找



#### 索引下推

在索引遍历过程中，**对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表字数**。



#### 最左前缀原则

[Mysql最左匹配原则](https://blog.csdn.net/sinat_41917109/article/details/88944290)

mysql 查询优化器，会自动优化查询顺序 ，所以等值查询不需要固定顺序







##  数据库事务

### 事务的四大特性（ACID）

隔离性、原子性、一致性、永久性



### MySQL事务的隔离级别, 分别有什么特点

- (READ UNCOMMITTED)读未提交: 一个事务能读到另一个为提交的事务

- (READ COMMITTED)读已提交：只有当一个提交后才能被另一个事务读取，解决脏读的问题，但是会造成不可重复读。
- (REPEATABLE READ)可重复读：可重复读就是一个事务只能读到另一个事务修改的已提交了事务的数据，但是第一次读取的数据，即使别的事务修改的这个值，这个事务再读取这条数据的时候还是和第一次获取的一样，不会随着别的事务的修改而改变。第一次读取的数据，可第二次读取的数据一致，解决
- (SERIALIZABLE)串行化：强制事务排序

基本是数据库默认隔离级别是(READ COMMITTED)读已提交，而mysql数据库是(REPEATABLE READ)可重复读

### 隔离级别产生的问题

- 脏读:脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据

- 幻读:第一次查询不存在的数据，第二次查询出现了，幻读侧重于新增或删除，而不可重复读是修改

- 不可重复读:第一次查询与第二次查询数据不对





#### 为什么mysql数据库默认是(REPEATABLE READ)可重复读

因为mysql老版本只支持binlog是STATMENT，如果使用提交读（Read-Committed）作为默认的隔离级别会导致丢失更新的问题。但是现在一般是修改数据隔离级别为提交读（Read-Committed）提高mysql的并发。



### 为什么大部分数据库默认隔离级别使用read-commited

-事务隔离级别为读提交时，写数据只会锁住相应的行，而事务隔离级别为可重复读的时候，如果检索条件没有索引会锁住整张表



#### mysql 使用(REPEATABLE READ)可重复读 有没有什么缺陷，需不需要更改事务隔离级别

[ TODO ] 



### mysql 可重复读和读已提交与MVCC

MVCC（多并发版本控制）mysql 是使用undo log实现的，这个日志每行记录的后面都有两个隐藏列，一个更新的版本号，一个是删除的版本号，当创建一个事务是，更新的版本号+1，每个事务值读取属于自己版本号的数据，这样就可以实现可重复读。

## 数据库锁机制
### 简介
数据库为了保证数据的一致性，使各种资源在并发访问下，变得有序而制定的规则

### 锁定机制
三种锁机制：行级锁定，页级锁定，表级锁
 - 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；
 - 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；   
 - 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

 适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。

### 如何加锁
 在执行select 会自动给所有表加读锁，在执行insert update 添加写锁，这个过程不需要用户干预

### 优化锁，提高并发率
- 减少锁定时间，提高并发度
- 减少复杂的query，将复杂的query拆分出小的分布进行
- 建立有效索引
```
尽量缩短“锁”的时间

使用锁的一个原则就是 尽可能晚地加锁，尽可能早地释放锁。也就是说，要合理规划处理逻辑，只在必须的最后时刻才执行update语句（加锁），并尽可能早提交或回滚事务（释放锁）。一个错误的例子就是：

   （1）update ………………………

   （2）复杂的耗时的java代码

   （3）commit
   
   如果可能话，就把 （1）和（2）调换下顺序，推迟加锁的时间。

缩短锁的时间，不能完全避免冲突，但是可以降低发生冲突的概率。就行在大街上走，走的快一些，尽量减少在大街上行走的时间，可以降低被熟人看见概率是一个道理。
```

### 锁的危害
[ TODO ]


### 参考资料
- https://www.cnblogs.com/sessionbest/articles/8689071.html



## 分表分库

#### 为什么要分库分表

当数据达到一定的数据量级，一般来说是500w左右时，当查询数据出现了瓶颈就需要进行分库分表了

- 分库能够增加数据库的并发能力
- 分表能够解决单表数据量过大带来的查询效率下降的问题



水平分表的方案

- 范围
- hash算法



#### 不同场景的分库分表方案「*」

[数据库分库分表的应用场景及解决方案](https://blog.csdn.net/sunhuiliang85/article/details/78418546)





## N+1问题

orm使用关联对象查询，一般来说会查出多少个对象就要查询多少次关联对象：假如查询出n个video，那么需要做n次查询comment，查询video是一次select，查询video关联的 comment，是n次，所以是n+1问题，其实叫1+n更为合理一些。

**解决方式：**

- 把N+1次查询变成2次查询，简单说 先执行 select *,category_id from article limited 0,N

  然后遍历结果列表,取出所有的category_id,去掉重复项

  再执行一次 select name from category where id in (category id list)

- join查询，该方法其实也有局限性，如果 表不在同一个服务器是不可以连表

- 懒加载：懒加载就是用到的时候再查询。有些orm支持





### 非聚集索引最多可以有多少个？

每个表你最多可以建立249个非聚簇索引。非聚簇索引需要大量的硬盘空间和内存





## explain

```
mysql> explain select * from dept_emp;
+----+-------------+----------+------+---------------+------+---------+------+--------+-------+
| id | select_type | table    | type | possible_keys | key  | key_len | ref  | rows   | Extra |
+----+-------------+----------+------+---------------+------+---------+------+--------+-------+
|  1 | SIMPLE      | dept_emp | ALL  | NULL          | NULL | NULL    | NULL | 331570 | NULL  |
+----+-------------+----------+------+---------------+------+---------+------+--------+-------+
```

### key

sql语句实际执行时使用的索引列，有时候mysql可能会选择优化效果不是最好的索引，这时，我们可以在select语句中使用force index(INDEXNAME)来强制mysql使用指定索引或使用ignore index(INDEXNAME)强制mysql忽略指定索引





### 数据库的连接池应该有多大？

连接数 = ((核心数 * 2) + 有效磁盘数)

[数据库连接池数调优](https://www.jianshu.com/p/472ff0694567)





## Sqlserver 与 PostgreSQL 与MySql 之间的对比

### PostgreSQL

- 能够并发地创建或删除索引（不锁表）；为表添加新的空字段不锁表，瞬间完成。而mysql5.6以前的版本会锁表，mysql5.6以后支持在线DDL，不会出现锁表

- 理论上PostgreSQL是个全栈数据库

  **OLTP**：事务处理是PostgreSQL的本行

  **OLAP**：citus分布式插件，ANSI SQL兼容，窗口函数，CTE，CUBE等高级分析功能，任意语言写UDF

  **流处理**：PipelineDB扩展，Notify-Listen，物化视图，规则系统，灵活的存储过程与函数编写

  **时序数据**：timescaledb时序数据库插件，分区表，BRIN索引

  **空间数据**：PostGIS扩展（杀手锏），内建的几何类型支持，GiST索引。

  **搜索索引**：全文搜索索引足以应对简单场景；丰富的索引类型，支持函数索引，条件索引

  **NoSQL**：JSON，JSONB，XML，HStore原生支持，至NoSQL数据库的外部数据包装器

  **数据仓库**：能平滑迁移至同属Pg生态的GreenPlum，DeepGreen，HAWK等，使用FDW进行ETL

  **图数据**：递归查询

  **缓存**：物化视图

  有些功能肯定是没有专业的做的好，但是都能用，MySQL就只能扮演OLTP关系型数据库的角色

参考资料[ * ]

PostgreSQL 与 MySQL 相比，优势何在？ - 冯若航的回答 - 知乎 https://www.zhihu.com/question/20010554/answer/94999834



### SqlServer

- 理论上增删改查，除了插入数据mysql比SqlServer要快，其他方面都没有SqlServer好





# 扩展读物

[《爱上面试官》系列-数据库索引](https://mp.weixin.qq.com/s/_9rDde9wRYoZeh07EASNQQ)

[mysql索引hash索引和b-tree索引的区别](https://www.cnblogs.com/baizhanshi/p/9869654.html)

[3万字总结，Mysql优化之精髓](https://www.cnblogs.com/chengxy-nds/p/12285215.html)






