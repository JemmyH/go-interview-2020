

[toc]

# 关系型数据库

## 关系数据库设计的三大范式

- 第一范式：保证每一个字段应该保证不可拆分，确保每个字段的原子性
- 第二范式：在保证第一范式的前提下，所有字段都必须依赖主键
- 第三范式：在保证第二范式的前提下，所有字段都必须直接依赖主键，而不是间接依赖

### 反范式

因为范式的目标是消除冗余，而造成了查询需要连接多张表增加了查询的复杂性与降低数据库性能。这是空间与时间的问题。而在实际场景中

一般是采取使用空间换取时间，进行适当的数据冗余来提高查询效率

冗余字段的规范：

- 不是频繁修改的字段
- 不能是text或者比较长的varchar

### 扩展阅读

[数据库设计三大范式](https://blog.csdn.net/dosthing/article/details/87954213)







## 索引

### 索引是什么，索引的优缺点

索引是数据库一种快速查询的机制

- 优点
  - 提高查询效率
- 缺点
  - 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加
  - 当数据量过大时，索引所占的空间越大

### 索引

mysql 的索引类型一般分为hash索引与B+树



#### hash索引

hash索引因为基于`哈希冲突` 的特性，使用场景如下

- 适合等值查询，不适合范围查询
- 并且值需要尽量保证不重复，不然容易造成hash冲突
  

#### B+树索引

##### 为什么mysql使用b+树？ [ TODO ]

- B+树的查询效率更加稳定,他能保证不管是插入还是查询都是在一个恒定时间内。不会造成太大的波动



##### 10亿数据查询一条记录最多需要几次磁盘访问？

B+树，可以把10亿个键值（指向10亿行记录的指针）保存在第3，4或者5层的高度上，所以每次对于10亿个键的搜索都进行3，4或者5次磁盘访问，大大减少了I/O次数。



#### MySQL 覆盖索引、最左前缀原则、索引下推

[mysql索引篇之覆盖索引、联合索引、索引下推](https://www.jianshu.com/p/bdc9e57ccf8b)



#### 索引覆盖 

查询的数据在索引树中可以找到,不需要回到数据树中去查找



#### 索引下推

在索引遍历过程中，**对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表字数**。



#### 最左前缀原则

[Mysql最左匹配原则](https://blog.csdn.net/sinat_41917109/article/details/88944290)

mysql 查询优化器，会自动优化查询顺序 ，所以等值查询不需要固定顺序







##  数据库事务

### 事务的四大特性（ACID）

隔离性、原子性、一致性、永久性



### MySQL事务的隔离级别, 分别有什么特点

(READ UNCOMMITTED)读未提交、(READ COMMITTED)读已提交、(REPEATABLE READ)可重复读、(SERIALIZABLE)串行化。

基本是数据库默认隔离级别是(READ COMMITTED)读已提交，而mysql数据库是(REPEATABLE READ)可重复读



#### 为什么mysql数据库默认是(REPEATABLE READ)可重复读

[ TODO ]



#### mysql 使用(REPEATABLE READ)可重复读 有没有什么缺陷，需不需要更改事务隔离级别

[ TODO ] 



## 数据库锁机制
### 简介
数据库为了保证数据的一致性，使各种资源在并发访问下，变得有序而制定的规则

### 锁定机制
三种锁机制：行级锁定，页级锁定，表级锁
 - 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；
 - 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；   
 - 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

 适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。

### 如何加锁
 在执行select 会自动给所有表加读锁，在执行insert update 添加写锁，这个过程不需要用户干预

### 优化锁，提高并发率
- 减少锁定时间，提高并发度
- 减少复杂的query，将复杂的query拆分出小的分布进行
- 建立有效索引
```
尽量缩短“锁”的时间

使用锁的一个原则就是 尽可能晚地加锁，尽可能早地释放锁。也就是说，要合理规划处理逻辑，只在必须的最后时刻才执行update语句（加锁），并尽可能早提交或回滚事务（释放锁）。一个错误的例子就是：

   （1）update ………………………

   （2）复杂的耗时的java代码

   （3）commit
   
   如果可能话，就把 （1）和（2）调换下顺序，推迟加锁的时间。

缩短锁的时间，不能完全避免冲突，但是可以降低发生冲突的概率。就行在大街上走，走的快一些，尽量减少在大街上行走的时间，可以降低被熟人看见概率是一个道理。
```

### 锁的危害
[ TODO ]


### 参考资料
- https://www.cnblogs.com/sessionbest/articles/8689071.html



## 分表分库

[ TODO ]

# explain









# 扩展读物

[《爱上面试官》系列-数据库索引](https://mp.weixin.qq.com/s/_9rDde9wRYoZeh07EASNQQ)

[mysql索引hash索引和b-tree索引的区别](https://www.cnblogs.com/baizhanshi/p/9869654.html)






