[toc]

# nosql

## redis

### redis单线程为什么执行速度这么快?

- redis 是纯内存操作，读写数据的时候都不会受到硬盘 I/O 速度的限制，所以速度快

- 单线程操作，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗
- 采用了非阻塞I/O多路复用机制



### hot key出现造成集群访问量倾斜解决办法

（1）：使用本地缓存

（2）：利用分片算法的特性，对key进行打散处理（给hot key加上前缀或者后缀，把一个hotkey 的数量变成 redis 实例个数N的倍数M，从而由访问一个 redis key 变成访问 N * M 个redis key）



### 1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？

在线上环境上使用scan指令。一般来说使用scan会出现一定的重复，可以对数据再进行去重处理





### Redis分布式锁

使用setnx实现，set有新的参数支持，可以使setnx与过期时间能一起设置，避免出现原子一致性问题



### 为啥redis zset使用跳跃链表而不用红黑树实现

- skiplist的复杂度和红黑树一样，而且实现起来更简单。
- 在并发环境下红黑树在插入和删除时需要rebalance，性能不如跳表



### 缓存雪崩、击穿、穿透

#### 缓存雪崩

缓存雪崩：大量key同时失效

解决方案：过期时间使用随机数

#### 缓存击穿

某个热点数据失效，导致大量数据直接访问db。导致db压力

解决方案：热点数据不失效，或者本地进行缓存、网关限流熔断措施

#### 缓存穿透

客户端恶意大量访问缓存不存在的数据，导致大量请求访问数据库

解决方案：对请求参数进行合法的校验。缓存不存在的值。或者使用布隆筛选器、网关限流熔断措施



### Redis采用的过期策略

redis 过期淘汰策略采用的是惰性删除和定期删除

- 定期删除：100ms 就*随机*抽取一些设置了过期时间的 key。如果失效了就移除掉
- 惰性删除：获取 key 的时候，如果此时 key 已经过期，就删除



### Redis 内存淘汰机制

内存淘汰机制：LRU：移除最近最少使用的 key（这个是最常用的）





### 缓存和数据库双写一致性问题

一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。答这个问题，先明白一个前提。就是如果对数据有强一致性要求，不能放缓存。我们所做的一切，只能保证最终一致性。另外，我们所做的方案其实从根本上来说，只能说降低不一致发生的概率，无法完全避免。因此，有强一致性要求的数据，不能放缓存。



### 如何解决Redis的并发竞争key问题

使用分布式锁



### redis特殊类型

#### Geo

存储地理位置信息

使用场景：实现附近的人或者事务



#### Bloom Filter（布隆过滤器）

布隆过滤器可以告诉你存储的东西**一定不存在**或者可能存在，会出现一定概率误判

场景：

- 解决缓存穿透的问题：把存在的数据放入布隆过滤器中
- 黑名单校验：把黑名单数据放入布隆过滤器中



### HyperLogLog

HyperLogLog则是一种算法，它提供了不精确的去重计数方案。Redis最多占用12k的内存



