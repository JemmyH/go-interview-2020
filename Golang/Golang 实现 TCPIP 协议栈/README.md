本项目主要是自己学习 **计算机网络**

本项目源代码：[https://github.com/google/netstack](https://github.com/google/netstack)

文字内容大多摘抄自 [Go 语言模拟实现 TCP IP 协议(付费课程 ￥79，不贵，推荐)](https://www.lanqiao.cn/courses/1300) ，自己做了总结与整理，作为笔记。

优先从 TCP 协议开始学习。

TCP 提供一种面向连接的、可靠的字节流服务。面向连接意味着不可能用于广播或者组播；字节流意味着消息直接没有明确的消息边界，即会出现我们常说的“粘包”现象。

怎么理解“面向字节流”？虽然应用程序和 TCP 的交互是一次一个数据块(大小不等)，但TCP 把 应用程序交下俩的数据仅仅看成一连串的无结构的字节流，TCP 并不知道所传送的字节流的含义，同时也不保证接收方收到的数据块和发送方发出的数据块具有对应的大小关系。比如发送方应用程序交给发送方的 TCP 共10个数据块，但接收方的 TCP 可能只用了4个数据块就把收到的字节流交付上层的应用程序。**接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。接收方的应用程序必须有能力识别收到的字节流，把它还原成有意义的应用层数据。**TCP 并不关心应用进程一次把多长的报文发送到 TCP 的缓存中，而是根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节(UDP 发送的报文长度是应用进程给出的)。如果应用进程传送到 TCP 缓存的数据块太长，TCP 就可以把它划分短一些再传送。如果应用进程一次只发来一个字节，TCP 也可以等待积累有足够多的字节后再构成报文段发送出去。

由 TCP 传给 IP 的块称为 **报文段(segment)**。

因为提供的是字节流的接口，TCP 必须把一个发送应用程序的字节流转化成一组 IP 可以携带的分组，这被称为 组包。**这些分组包含序列号，该序列号代表的是每一个分组的第一个字节在整个字节流中的字节偏移，而不是分组号。** 这使得分组大小是可变的，并且允许他们重新组合，即 重新组包。

TCP 中叫 segment(报文段)，IP 中叫 packet(网络数据包)，Link 中叫 frame(帧)。

TCP 头部结构：

```bash
/*
 TCP Header Format

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Source Port          |       Destination Port        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Sequence Number                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Acknowledgment Number                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Data |           |U|A|P|R|S|F|                               |
   | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
   |       |           |G|K|H|T|N|N|                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Checksum            |         Urgent Pointer        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
*/
```

你需要注意这四个很重要的参数：

1.  Sequence Number 是包的序号，用来解决网络包乱序的问题；
2.  Acknowledgement Number也就是 ACK，用于收到确认，解决不丢包的问题；
3.  Window 也叫 Advertised-Window，用在滑动窗口，用于解决流控；
4.  TCP Flag，包的类型，主要是用于操控TCP的状态机的。

TCP 虽然是面向字节流的，但 TCP 传送的数据单元却是报文段。一个 TCP 报文段分为首部和数据两部分。TCP 报文段首部的前20个字节是固定的(上图中一行 32 位为 4 个字节)，后面有4n字节是根据需要而增加的选项(n是整数)。因此 TCP 首部的最小长度是20字节。

6 个控制位的作用：

-   `紧急 URG(URGent)` 当 URG=1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)，而不是按原先的排队顺序来传送
-   `确认 ACK(ACKnowledgment)` 仅当 ACK=1 时确认号字段才有效。当 ACK=0 时，确认号无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置1
-   `推送 PSH(Push)` 当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能够收到对方的响应
-   `复位 RST(ReSeT)` 当 RST=1 时，表明 TCP 连接中出现严重差错(如由于主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接
-   `同步 SYN(SYNnchronization)` 在连接建立时用来同步序号。当 SYN=1 而 ACK=0 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 SYN=1 和 ACK=1
-   `终止 FIN(FINis)` 用来释放一个连接。当 FIN=1 时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。

>   我们最需要关注的是 ACK、SYN 和 FIN：假设 A 是客户端，B 是服务端，A 想要和 B 建立连接，我们看下三次握手过程：
>
>   第一次，A 发送的包中，标志位 SYN=1，Sequence Number = X(随机数，也叫 ISN，Initial Sequence Number)，其余均为默认值；
>
>   第二次，B 收到 A 的连接请求之后，需要对这个包进行确认，返回一个包，其中 SYN=1、ACK=1 ，并且设置 Sequence Number = Y(另一个随机数), Acknowledgment Number = X+1(客户的 ISN+1)；
>
>   第三次，A 收到 B 的回复后，需要回复一个包，其中 ACK=1，Sequence Number = X+1，Acknowledgment Number=Y+1。
>
>   至此，三次握手结束，连接建立，接下来 A 向 B 发送的数据包的 Sequence Number 将从 X+1 开始，B 向 A 发送的数据包的 Sequence Number 将从 Y+1 开始。也就是说，建立连接时，客户端A宣称自己的初始序列号是 X，服务端B宣称自己的初始序列号是 Y，但是建立连接之后真正的数据的传输却是从各自的初始序列号+1开始——**这是因为SYN请求本身需要占用一个序列号**。
>
>   —— [理解TCP序列号（Sequence Number）和确认号（Acknowledgment Number）](https://xzchsia.github.io/2020/08/31/tcp-seq-ack/)
>
>   
>
>   另一种理解：
>
>   第一次握手： 建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；
>
>   第二次握手： 服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；
>
>   第三次握手： 客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。

常见的 Options 选项：

![img](https://pic1.zhimg.com/80/v2-ae6ac6f9a358b2289c21ed9672a84bec_720w.jpg)



**发送窗口：**

TCP是双工的协议，会话的双方都可以同时接收、发送数据。TCP会话的双方都各自维护一个“发送窗口”和一个“接收窗口”。其中各自的“接收窗口”大小取决于应用、系统、硬件的限制（TCP传输速率不能大于应用的数据处理速率）。各自的“发送窗口”则要求取决于对端通告的“接收窗口”，要求相同。

对于 TCP 会话的发送方，任何时候其发送缓冲区内的数据都可以分成 4 类：

![发送方缓冲区](https://img-blog.csdn.net/20160906081402924)

-   Category1: 已经发送并且对方已经确认收到的
-   Category2：已经发送但还未收到确认的
-   Category3：对方允许发送但还未发送的
-   Category4：对方不允许发送且还未发送的

当接收到对方的新的 ACK 之后，窗口滑动，比如当收到 ACK=36 时的窗口滑动：

![](http://static.oschina.net/uploads/space/2015/0730/110101_XiAd_1469576.jpg)

参考资料：

-   [理解TCP序列号（Sequence Number）和确认号（Acknowledgment Number）](https://xzchsia.github.io/2020/08/31/tcp-seq-ack/)