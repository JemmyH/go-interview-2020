![网络编程脑图](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjkou63e46j30u00vodlq.jpg)

## 一、`TCP/IP` 协议簇

### 1. 计算机网络的标准化极其组织

在国际上，负责制定、实施相关网络标准的标准化组织众多，主要有以下几个：

-   **国际标准化组织(`ISO`，`Internationale Organization for Standardization`)**：制定有 `OSI参考模型`、`HDLC` 等；
-   **国际电气电子工程师协会(`IEEE`，`Institute of Electrical and Electronics Engineers`)**：世界上最大的专业技术团体，由计算机和工程学专业人士组成，最著名的研究成果是 [`802标准`](https://zh.wikipedia.org/wiki/IEEE_802)。
-   **国际电信联盟(`ITU`，`International Telegraph and Telephone Consultative Committee`)**：制定了大量有关远程通信的标准。

### 2. 协议

**协议，就是规则的集合。**要在错综负责的网络环境中有条不紊地传输数据，就必须遵守事先约定好的一系列规则，这些规则明确规定了所要交换的数据的格式以及有关同步的问题。这些为了网络中的数据进行交换的规则、约定或者标准，就是我们说的 **网络协议(`Network Protocol`)**。**通过网路协议进行数据交换的双方必须是对等的、水平的实体，不对等的实体之间是没有协议可言的**。比如使用 `TCP/IP` 协议栈进行通信的两个结点，结点`A`的传输层和结点`B`的传输层之间存在协议(`IP协议`)，但是结点`A`的传输层和结点`B`的网络层之间是不存在协议的。

简单来说，**`协议 = 语法 + 语义 + 同步`**。**语法** 规定了传输数据的格式；**语义** 规定了所要完成的功能，即需要发出何种控制信息、完成哪种动作以及针对不同的请求作出何种应答；**同步** 规定了执行各种操作的条件、时序关系。一个完整的协议通常应该具有 **线路管理(建立连接、释放连接等)**、**差错控制**、**数据转换** 等功能。

### 3. `OSI七层模型`

![OSI七层模型](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjkro635u5j31el0u0u0x.jpg)

### 4. `TCP/IP` 模型

对于 `OSI七层模型`，我们认为其底下两层是随系统提供的设备驱动程序和网络硬件，通常情况下，除非需要知道数据链路的某些特性，我们不必去关心这两层的情况；其上面三层可以合并为一层，称为应用层，即web页面、Telnet命令行、FTP服务器等其他网络应用程序所在的层，因为对于 `IP协议` 所在的网络层来说，最上面的三层没有任何区别。这样我们可以看到下面的结构：

![TCP/IP概览](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjkthunzcaj32790u0b2a.jpg)

从字面意义上讲，有人可能会认为 `TCP/IP` 是指 `TCP` 和 `IP` 两种协议。然而在很多情况下，`TCP/IP` 只是利用 `IP` 进行通信时所必须用到的协议群的统称。具体来说，`IP` 或 `ICMP`、`TCP` 或 `UDP`、`TELNET` 或 `FTP`、以及 `HTTP` 等都属于 `TCP/IP` 协议。他们与 `TCP` 或 `IP` 的关系紧密，是互联网必不可少的组成部分。`TCP/IP` 一词泛指这些协议，因此，有时也称 `TCP/IP` 为 **网际协议群**。

下面我们学习 `TCP/IP` 协议簇中四层的细节：

#### 4.1 网络接口层(链路层)

##### 网卡及MAC地址

计算机与外界局域网的连接是通过主机箱内插入的一块 **网络接口板**(又称 **网络适配器`Adapter`**) 或 **网络接口卡**(`Network Interface Card`， `NIC`) 实现的，在这里我们统称为 **网卡**。网卡上装有 **处理器** 和 **存储器**，是工作在数据链路层的网络器件，它是连接计算机实体和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、数据的编码与解码、数据缓存等功能。

全世界的每一块网卡在出厂时都有一个唯一的代码，我们称为 **介质访问控制(`MAC`，`Media Access Control`) 地址**，这个地址用于控制当前主机在网络上的数据通信。`MAC` 地址长 6 字节，一般使用由连字符或者冒号分割的 6 个十六进制数标识，如 `ac:bc:32:96:86:01`，高 24 位为网卡制造厂商编码，低 24 是该厂商自行分配的网卡序列号。

##### 通信方式

从通信双方信息的交互方式看，可以分为三种基本方式：

1.  **单工**。单工通信只支持信号在一个方向上传输（正向或反向），任何时候不能改变信号的传输方向。例如无线电广播、电视广播等；
2.  **半双工**。半双工通信允许信号在两个方向上传输，但某一时刻只允许信号在一个信道上单向传输。
3.  **全双工**。全双工通信允许数据同时在两个方向上传输，即有两个信道，因此允许同时进行双向传输。

#### 4.2 网际层(网络层)

`IP协议` 是 `TCP/IP` 协议簇的核心协议。正所谓 `Everything over IP`，所有 `TCP`、UDP、ICMP 和 IGMP 数据都通过 `IP` 数据报传输。`IP协议`  提供了一种 **尽力而为**、**无连接** 的数据报交付任务。“尽力而为” 即不保证 `IP` 数据报能成功地到达目的地，任何可靠性必须通过上层协议(如 `TCP`)提供。`IPv4` 和 `IPv6` 都使用这种尽力而为的基本交付模式。“无连接” 是指 `IP协议` 不维护网络单元中数据报相关的任何链接状态信息，**每个数据报相对于其他数据报都是独立的**，这也意味着 `IP` 数据报可以不按发送顺序交付，如果没有时序控制，可能导致错误。

`IP协议` 有 `IPv4` 和 `IPv6`两个版本。其中后者是前者的扩展，在不就的未来，`IPv4` 的地址将耗尽，到时候将会使用 `IPv6`。

>   对应的 RPC文档：[https://tools.ietf.org/html/rfc791](https://tools.ietf.org/html/rfc791)

##### 4.2.1 `IPv4`

**`IPv4`数据报格式**

一个 `IP` 数据报由首部和数据两部分组成，其中首部的前一部分长度固定，共 20 字节，是所有 `IP` 数据报必须具有的；后一部分是一些可选字段，其长度可变，用来提供错误监测和安全等机制。

其组成格式如下：

![IPv4报文格式](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjlav7ah23j30xc0u0x6p.jpg)

解释一下其中字段的含义：

-   **版本(Version)**：4 bits，指 `IP` 的版本，在这里为 4；
-   **首部长度(Header Length)**：4 bits，以 32 位(4 字节)为单位，则最大值为 `(2^4-1) * 4B = 60B`，最小值为 `5 * 4B = 20B`，即没有任何可选字段。
-   **服务类型(Type Of Service)**：8 bits，指明在不同的网络环境下所能提供的服务类型，根据不同的类型选择不同的优先级。(具体细节请自行查看RFC文档)
-   **总长度(Total Length)**：16 bits，包括头部和数据部分的整个数据报长度，单位为 1B，则最大长度为 `2^16 - 1 = 65535B`，用十六进制表示。
-   **标识(Identification)**：16 bits，它是一个计数器，每产生一个数据报就加 1，注意它并不是序号。当一个数据报过大时，必须分片，分片时每个数据报都会复制一次标识位，以便能正确组装原来的数据报。
-   **标志(Flag)**：3 bits，标示分片用。第 0 位时预留位，默认0；第 1 位是 `DF`，`DF = 1` 表示不允许分片，`DF = 0` 表示允许分片；第 2 位时 `MF`，`MF = 1` 表示后面还有分片，`MF = 0` 表示这是最后一个分片。
-   **片位移(Fragment Offset)**：16 bits，表示较长的分组在分片之后，某片在分组中的相对位置。片位移以 8 字节为偏移单位，即每个分片的长度一定是 8B 的整数倍。
-   **生存时间(TTL)**：8 bits，数据报在网络中可通过的路由器数的最大值，表示分组在网络中的寿命，以确保分组不会在网路中循环传送。路由器在转发分组前，先把 `TTL` 减一，当 `TTL = 0` 时，该分组必须被丢弃。
-   **协议(Protocol)**：8 bits，表示此分组携带的数据使用传输层的何种协议，即分组的数据应该交给哪个传输层协议，比较关心的是，6 表示 `TCP`，21 表示 `UDP`。
-   **首部校验和(Header Checksum)**：16 bits，首部校验和只校验分组的首部，而不校验数据部分。
-   **源地址(Source Address)**：32 bits，标识发送方的 `IP` 地址；
-   **目的(Destination Address)**：32 bits，标识接受方的 `IP` 地址。

**`IP` 数据报分片**

一个链路层数据报能承受的最大数据量称为 **最大传送单元(`MTU`)**。因为 `IP数据报` 是被封装在链路层的数据报中，因此链路层的 `MTU` 严格限制着 `IP数据报` 的长度。当 `IP数据报` 的总长度大于链路 `MTU` 时，就需要将 `IP数据报` 中的数据部分，分装在两个或者多个更小的 `IP数据报` 中，这些相对于原来较大的 `IP数据报` 的较小的数据报称为 **`分片`** 。

分片在目的地的网路层会被重新组装，分片的切分和组装需要用到 `IP数据报` 首部的 **标识**、**标志** 和 **片位移** 字段。通过一个例子来说明：

![IP数据报分片](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjlctpypepj32l40u04qp.jpg)

**`IPv4` 地址**

**TODO**

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjld6r6femj305h03e3yx.jpg)

##### 4.2.2 `IPv6`

##### 4.2.3 `ICMP`

#### 4.3 传输层

传输层提供应用进程之间的逻辑通信(注意区分，网络层提供主机与主机之间的逻辑通信)，应用进程之间的通信也称 **端到端的逻辑通信**，这里的 **逻辑通信** 的意思是，传输层之间的通信好像是互相沿着水平方向传送数据，不用去关注下层的实现细节，屏蔽了底层网络核心的细节，但事实上这两个进程之间并没有一条水平方向的物理连接。

**端口** 能够让应用层的各种应用进程将其数据通过端口向下交给传输层，以及让传输层知道应该将报文段中的数据通过哪个端口交付给目的进程。这个端口就是我们平常说的 **段口号**。端口号只具有本地意义，即端口号可以表示本机的应用层的各进程，在因特网的不同计算机的相同端口号是没有任何联系的。段口号的长度为 16 位，能够表示 `2^16` 个不同的端口号。根据端口号的范围，可将其划分为三类：

1.  **周知端口**：`[0, 1023]` 区间内的端口，由 **[IANA](https://www.iana.org/)** 组织同意管理，固定分配给一些非常重要的服务，让所有用户都知道。比如21端口分配给FTP服务，25端口分配给SMTP（简单邮件传输协议）服务，80端口分配给HTTP服务等
2.  **注册端口**：`[1024, 49151]` 区间内的端口，一般由公司或者个人声明、大家熟知的端口，比如 `ElasticSearch` 默认使用 `9200`，`MySQL` 默认使用 `3306`，但是我们可以手动去改变。
3.  **动态端口**：`[49152, 65535]`区间内的端口，这类端口在用户进程运行时会自动选择一个，用完之后释放，下次再使用时再重新分配。

>   你可以在这里找到所有的端口分配：[https://web.archive.org/web/20010604223215/http://www.iana.org/assignments/port-numbers](https://web.archive.org/web/20010604223215/http://www.iana.org/assignments/port-numbers)

再来认识一下 `TCP/IP` 中的 **socket**。在前面的网络层中，我们了解到，网络层提供的是主机到主机之间的逻辑通信，**任何一个接入互联网的主机都有一个唯一的网络地址**，我们称为 `IP 地址`，也就是说，`IP 地址` 可以唯一标识一个网络中的主机。而传输层提供的是应用进程之间的逻辑通信，那如何唯一标识一个主机上的一个应用进程呢？答案就是 `IP + 协议 + 端口`，即 `(IP地址, 协议, 端口)` 这样的三元组就可以唯一标识一个网络中的应用进程。

最后说一下什么是 **面向连接** 与 **面向无连接**。这也是 `TCP` 和 `UDP` 之间的主要区别之一。`TCP` 客户端先与服务端通过 **三次握手** 建立一个连接，之后开始传输数据；而 `UDP` 的客户端与服务端不存在任何的长期关系。举例来说，一个 `UDP` 客户端可以创建一个套接字并发送一个数据给特定的服务器，然后可以立即用同一个套接字发送另一个数据报给另一个服务器；同样地，一个服务器可以用同一个套接字从若干不同的客户接收用户数据报，每一个用户一个数据报。

##### 4.3.1 `UDP`

**`UDP`(`User Datagram Protocol`，用户数据报协议)** 是一个简单的传输层协议，你可以在 [User Datagram Protocol](https://tools.ietf.org/html/rfc768) 找到它的详细说明。应用进程通过套接字写入一个消息，随后该消息被封装到一个 `UDP 数据报` 中，该 `UDP 数据报` 又被封装到一个 `IP 数据报` 中，之后发送到目的地。`UDP` 协议并不保证 `UDP 数据报` 会到达其目的地，也不保证各个数据报的先后顺序在跨网络传输后保持不变，也不保证每个数据只到达一次。

我们看一下一个 `UDP 数据报` 的组成：

![UDP数据报](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjmkoyvezlj31br0u01kx.jpg)

解释一下其中字段的含义：

-   **发送端端口(`Source Port`)**：16 bits，发送端的端口，该字段是可选的，主要用在一些不需要返回的通信中，此时此字段置为0即可。
-   **接收端端口(`Destination Port`)**：16 bits，表示接收端的端口号。
-   **报文总长度(`Length`)**：16 bits，表示`UDP 数据报`首部的长度 和 数据的长度 之和。单位为 `8B`，即一个 `UDP 数据报` 的最大长度是 `2^16 * 8B = 524288B = 512 KB`。当然实际运输时可能不会一次性发送这么大的包，会在网络层装入 `IP 数据报` 时被分片。
-   **校验和(`Checksum`)**：16 bits，其计算方法为：checksum(`UDP 数据报` 中的所有数据 + 一个伪头部 + 为了将 `UDP数据报` 补充成 16bits 的整数倍而补充的0)。

>   下面是伪头部的结构：
>
>   ![伪头部](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjmlfbnqvyj323o0rwnem.jpg)
>
>   其中包含 源IP 和 目的IP，`UDP`协议的代码17，长度字段就是UDP包长度字段值。
>
>   既然是“伪”首部，也就是假的，不仅是“假”首部，而且“假”到连地址空间都没有，其中的信息是从数据报所在IP分组头的分组头中提取的。也就是说伪首部是不占地址空间的，在实际传输中不存在这样的字段。只是在使用的时候把它拿出来一下。
>
>   其次，既然设置了伪首部，那么肯定就是有用的——为了计算检验和！书中原话“其目的是让UDP两次检查数据是否已经正确到达目的地”，具体是那两次呢？我们注意伪首部字段：32位源IP地址、32位目的IP地址、8位协议、16位UDP长度。由此可知，第一次，通过伪首部的IP地址检验，UDP可以确认该数据报是不是发送给本机IP地址的；第二，通过伪首部的协议字段检验，UDP可以确认IP有没有把不应该传给UDP而应该传给别的高层的数据报传给了UDP。
>
>   所以最终逻辑上的 `UDP 数据报` 结构应该是这样的：
>
>   ![UDP数据报](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjmo3eova5j32910u01ky.jpg)

##### 4.3.2 `TCP`



##### 4.3.3 `SCTP`





#### 4.4 应用层

这一层我们只关心 **超文本传输协议`HTTP`**。

##### 4.4.1 概述

`HTTP`(`Hypertext Transfer Protocol`) 超文本传输协议，是在互联网上进行通信时使用的一种协议。最常见的场景是用户与浏览器之间的通信。它属于 应用层 协议，底层使用 `TCP` 进行可靠的传输。

`HTTP` 在传输一段数据时，会以 `流` 的形式将报文数据的内容通过一条已经 “打开”的 `TCP` 传输通道 **按序传输**。传输层的`TCP` 接到上层应用交给它的数据流之后，会按序将数据流打包成一个个的分段，之后交给网络层的 `IP` ，通过网络进行传输。接收端则与这个过程相反，它们将接收到的分段按照顺序组装好，传递给上层的 `HTTP` 进行处理。

###### `URI`

`URI(Uniform Resource Identifier, 统一资源标识符)`，用于标识某一互联网资源，允许用户通过制定的格式访问数据，其格式如下：

```bash
                    hierarchical part
        ┌───────────────────┴─────────────────────┐
                    authority               path
        ┌───────────────┴───────────────┐┌───┴────┐
  abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1
  └┬┘   └───────┬───────┘ └────┬────┘ └┬┘           └─────────┬─────────┘ └──┬──┘
scheme  user information     host     port                  query         fragment

如：

```



##### 4.4.2 HTTP 1.1

##### 4.4.3 HTTP 2.0

##### 4.4.4 HTTP 3.0

##### 4.4.5 HTTPS

## 二、`Socket` 编程

### 1. 什么是 `socket` 编程

使用 `TCP/IP` 协议的应用程序通常采用应用编程接口：**UNIX BSD的套接字(socket)** 和 **UNIX System V的TLI**（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用 `socket`。`socket` 起源于 `Unix`，而 `Unix/Linux` 基本哲学之一就是**“一切皆文件”**，都可以用`open –> write/read –> close`模式来操作。`socket` 就是该模式的一个实现，即 `socket` 是一种特殊的文件，一些 `socket` 函数就是对其进行的操作(读/写IO、打开、关闭)。

如果要给 `socket` 一个定位，那应该是：`socket` 就像是一组 `接口(interface)`，它将更复杂的 `TCP/IP` 协议簇隐藏在 `socket` 接口后面，只对用户暴露更简单的接口，就像操作系统隐藏了底层的硬件操作细节而只对用户程序暴露接口一样，它是 应用层 与 `TCP/IP`协议簇 通信的中间软件抽象层。可以用一张图来表示这个关系：

![socket的定位](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjmnmaizsaj31c10u0e3v.jpg)

而整个 `socket` 工作流程可以用下面这张图来表示：

![socket工作流程](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjmqesnq9xj30u01g2b21.jpg)

如果用语言描述的话，服务端首先初始化 `socket`，然后与端口绑定(`bind`)，并对端口进行监听(`listen`)，阻塞(`accept`) 等待客户端连接；在客户端这边，先初始化一个 `socket`，通过 **TCP 三次握手** 与服务端简历连接(`connect`)，服务端接收请求(`read`)并处理请求，然后将结果返回客户端(`write`)，客户端读取数据(`read`)，最后关闭连接(`close`)，一次通信结束。

接下来我们详细看看这几个函数：

### 2. `socket` 系列函数

#### 2.1 `socket()`

为了执行 `网络I/O`，一个进程第一件事就是调用 `socket()` 函数，传入期望的 **通信协议类型**，得到一个 **套接字描述符**：

```c
int socket(int family, int type, int protocol);  // 如果创建成功，会返回非负整数 sockfd，即套接字描述符 
```

其中 `family` 指明 **协议簇**：

|  `family`  |     说明      |
| :--------: | :-----------: |
| `AF_INET`  |  `IPv4` 协议  |
| `AF_INET6` |  `IPv6` 协议  |
| `AF_LOCAL` | `Unix` 域协议 |
| `AF_ROUTE` |  路由套接字   |
|  `AF_KEY`  |  密钥套接字   |

`type` 指明 **套接字类型**：

|      `type`      |      说明      |
| :--------------: | :------------: |
|  `SOCK_STREAM`   |  字节流套接字  |
|   `SOCK_DGRAM`   |  数据报套接字  |
| `SOCK_SEQPACKET` | 有序分组套接字 |
|    `SOCK_RAW`    |   原始套接字   |



`protocol` 指 **传输层协议**：

|   `protocol`   |      说明       |
| :------------: | :-------------: |
| `IPPROTO_TCP`  | `TCP` 传输协议  |
| `IPPROTO_UDP`  | `UDP` 传输协议  |
| `IPPROTO_SCTP` | `SCTP` 传输协议 |

但并非所有的 `family` 和 `type` 的组合都是有效的，下表给出有效的组合以及对应的具体协议：

![family和type组合](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjmw3h9xkpj30kn0bewfe.jpg)

>   “是” 表示该组合也是有效的，但是目前没有现成的协议供使用。空白则表示 非有效组合。
>
>   `socket()` 函数在成功时会返回一个小的非负整数值，它与文件描述符类似，我们把它称为 **套接字描述符(`socket descriptpr`,  `sockfd`)**，这个描述符唯一描述一个 `socket`。

#### 2.2 `bind()`

`bind()` 将一个本地协议地址赋予一个套接字。对于网际协议，协议地址是 32 位的`IPv4` 地址 或 128 为的 `IPv6` 地址与 16 位的 `TCP` 或 `UDP` 端口号的组合：

```c
int bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen); // 返回： 0成功，-1失败
```

`sockfd` 是由 `socket()` 函数返回的套接字描述符。

`myaddr` 是一个指向特定协议的地址结构的指针，表示绑定给 `sockfd` 的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，比如 `IPv4` 对应的是：

```c
struct sockaddr_in {
    sa_family_t    sin_family; /* Address Family: AF_INET */
    in_port_t      sin_port;   /* Port Number */
    struct in_addr sin_addr;   /* Internet Address */
};

/* Internet address. */
struct in_addr {
	__be32	s_addr;
};
```

`IPv6` 对应的是：

```c
struct sockaddr_in6 {
	unsigned short int	sin6_family;    /* AF_INET6 */
	__be16			sin6_port;          /* Port Number # */
	__be32			sin6_flowinfo;      /* IPv6 flow information */
	struct in6_addr		sin6_addr;      /* IPv6 address */
	__u32			sin6_scope_id;      /* scope id (new in RFC2553) */
};

/*
 *	IPv6 address structure
 */
struct in6_addr {
	union {
		__u8		u6_addr8[16];
		__be16		u6_addr16[8];
		__be32		u6_addr32[4];
	} in6_u;
};
```

`Unix 域` 对应的是：

```c
#define UNIX_PATH_MAX	108

struct sockaddr_un {
	__kernel_sa_family_t sun_family; /* AF_UNIX */
	char sun_path[UNIX_PATH_MAX];	/* pathname */
};
```

`addrlen` 是第二个参数地址结构的长度。正如大多数 `socket` 接口一样，内核不关心地址结构，当它复制或传递地址给驱动的时候，它依据这个值来确定需要复制多少数据。这已经成为 `socket` 接口中最常见的参数之一了。

对于 `bind()` 函数中的 `IP` 和 端口，不管是服务端还是客户端，都可以指定，也都可以不指定，也都可以指定其中一个，只不过会有不同的效果。

对于服务器而言，一般情况下要指定 `IP` 和 端口，因为它是提供服务的一方，必须明确自己的身份，让客户端能够在网络中找到，即通过之前说的三元组 `(IP地址, 协议, 端口)` 来唯一标识这个进程(服务)。不过，服务器进行 `IP` 绑定的时候，有 具体的 `IP` 和 通配 `IP` 之分，前者表示只接收来自该 `IP` 的连接，后者表示可以接受来自任何 `IP` 的连接，来者不拒。而服务器启动的时候的端口，一般都是众知端口，如果没有指定，`connect()` 或者 `listen` 的时候内核会为其指定一个。

对于客户端而言，没有必要去指定端口，内核会选择一个可用的动态端口。如果客户端指定了 `IP` 地址，则相当于为发送出去的 `IP数据报` 分配了源IP地址，但这时这个`IP` 地址必须属于这个主机，不能分配一个不存在的 `IP`。

简而言之，采用 `TCP` 或者 非对等的 `UDP` 通信时，客户端不需要 `bind()` 他自己的 `IP` 和端口号，如果需要的话，内核会确定源 `IP` 地址并选择一个临时端口作为源端口，而服务器必须要 `bind()` 自己本机的 `IP` 和端口号。

#### 2.3 `connect()`

`TCP` 客户端使用 `connect()` 函数用来建立与服务端的连接：

```c
int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen);  // 0成功 -1出错
```

参数描述与 `bind()` 函数一样，不过这个时候，套接字地址结构必须含有服务器的 `IP` 地址 和 具体的端口号。

如果是 `TCP` 套接字，调用 `connect()` 会激发 `TCP` 的 **三次握手** 过程，而且仅在连接成功或者出错时才返回。

#### 2.4 `listen()`

```c
int listen(int sockfd, int backlog);  // 0成功 -1出错
```

`listen()` 函数仅由服务器调用，它做两件事：

1.   当我们用 `socket()` 创建一个 套接字 时，它默认是一个主动套接字，即它默认是一个将要调用 `connect()` 对服务器发起连接的客户端套接字。而 `listen()` 函数会把一个这样的主动套接字变成一个被动套接字，指示内核接受指向该套接字的。连接要求。对外表现效果就是，`TCP 状态转移图` 中，`listen()` 会将 `CLOSED 状态` 转换成 `LISTEN 状态`。
2.  第二个参数指定了内核应该为响应的套接字可以排队的最大连接个数。

>   当进程在处理一个个连接请求的时候，有可能还存在其他的链接请求，因为 `TCP` 连接有一个三次握手的过程，并非原子性的，所以就有可能存在一种半连接状态。这时就有可能出现尝试连接的用户数太多、服务器无法快速完成连接的情况。为了解决这个问题，内核会在自己的进程空间中维护两个队列，而且这两个队列总长度不能超过限定值 `backlog`：
>
>   -   未完成连续队列：在三次握手期间，客户端发送一个 `SYN` 并到达服务器请求建立连接，而服务器正在等待完成该过程；
>   -   已完成连续队列：三次握手完成后 或者 连接超时，该连接就会被从 **未完成连续队列** 转移到 **已完成连续队列** 的末尾，当进程调用 `accept()` 时，会从队列头部返回一个连接出去。如果当前队列为空，那么进程将被置于休眠状态，知道此队列中有数据。
>
>   当然，内核空间有限，我们不能随意指定一个 `backlog` 值，一般在 30 以内。

#### 2.5 `accept()`

TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端依次调用socket()、connect()之后就想TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作：

```c
int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen);  // 成功则返回非负的已连接套接字，出错返回-1
```

`accept()` 主要用在基于连接的套接字类型，比如 `TCP` 或者 `SCTP` 。它从 `listen()` 的 **已完成连续队列** 中取出队首的一个连接，创建一个不同于 `socket()` 创建的(称为 **监听套接字(`listening socket`)**)新的套接字——**已连接套接字(`connected socket`)**，并返回指向该套接字的文件名描述符。

>   需要区分这两个套接字。一般情况下，服务器仅仅创建一个监听套接字，它在该服务的生命周期内一直存在；内核为每一个建立连接的客户创建一个新的套接字，当服务完成后，这个新创建的 **已连接套接字** 就会被关闭。

`accept()` 成功则返回 **已连接套接字** 的描述符，失败则返回 -1。另外需要注意后两个参数，传输的是指针，这其实也是返回值，因为 `C 语言` 中函数没有多返回值，因此采用这种直接修改指针的方式复制，他们分别代表 客户端进程的协议地址、指向改地址的大小。如果我们对客户端协议不感兴趣，可以将这两个指针都置空。

#### 2.6 `read()` 、 `write()`

经过上面的几个步骤，客户端与服务端已经建立了连接，此时可以调用 `网络I/O` 进行读写操作，即实现不同网络中不同进程之间的通信。

```c
ssize_t read(int fd, void *buf, size_t count);
ssize_t write(int fd, const void *buf, size_t count);
```

一般也会用到以下几组函数：

>   -   `read()` / `write()`
>   -   `recv()` / `send()`
>   -   `readv()` / `writev()`
>   -   `recvmsg()` / `sendmsg()`
>   -   `recvfrom()` / `sendto()`

#### 2.7 `close()`

通常情况下，`Unix` 系统中 `close()` 也用来关闭套接字，并终止 `TCP` 连接：

```c
int close(int sockfd); 
```

`close()` 将一个套接字标记为 **已关闭**，然后立即返回到调用进程，被关闭的套接字描述符不能再由进程使用，也就是说它不能再作为 `read()` 或 `write()` 的第一个参数。但是 `TCP` 的连接并不是立即关闭的，因为此时有可能出现 已经存在于 `TCP` 发送队列的数据，等发送完毕后才会去执行 `TCP` 的关闭流程。

#### 2.8 并发服务器的底层设计

我们先了解一下 `Unix` 系统中的 `fork()` 函数，它是 `Unix` 系统中 **派生出新进程** 的 **唯一** 方法：

```c
pid_t fork(void);
```

该函数的难以理解之处在于 **调用一次，返回两次**。它在调用进程(父进程)中返回一次，返回值是新派生出的进程(子进程)的进程 `PID` ；在子进程中又返回一次，返回值为 0 。因此可以根据返回值来判断当前进程时父进程还是子进程。

>   任何一个子进程都只有一个父进程，而一个父进程可以有多个子进程。子进程可以通过库函数 `getppid()` 获取父进程的 `PID` ，但是父进程无法获取各个子进程的 `PID` 。

一个进程调用 `fork()` 函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的栈段所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。需要注意的一点：就是调用 `fork()` 之后，两个进程同时执行的代码段是 `fork()` 函数之后的代码，而之前的代码已经由父进程执行完毕。看一个 `demo`：

```c
#include <stdio.h>
#include <unistd.h>

int main()
{
    int forkid;
    int count = 0;
    printf("fork 之前, count: %d\n", count);

    forkid = fork();  // fork 出子进程

    if (forkid == 0)
    {
        // 子进程
        printf("我是子进程\t");
        count++;
        printf("子进程中 count: %d\n", count);
    }
    else
    {
        // 父进程
        printf("我是父进程\t");
        count++;
        printf("父进程中 count: %d\n", count);
    }

    count++;

    printf("主进程中 count: %d\n", count);

    return 0;
}

// 输出结果：
/*
fork 之前, count: 0
我是父进程      父进程中 count: 1
主进程中 count: 2
我是子进程      子进程中 count: 1
主进程中 count: 2
*/
```

父进程在调用 `fork()` 之前打开的所有文件描述符在 `fork()` 之后是和子进程共享的，而目前大多数网络服务器正是利用了这个特性来做到并发：父进程 `accept()` 之后 `fork()` 出一个子进程，此时二者共享之前已经连接好的套接字，子进程也持有一个该连接的套接字，这个时候父进程可以关掉当前的连接，继续接收另一个连接。这个过程可以用下面这个伪代码来描述：

```c
int main()
{
    int listenfd, connfd;

    listenfd = socket();   // 创建一个全局的 监听套接字
    bind(listenfd, ...);   // bind ...
    listen(listenfd, ...); // listen ...

    for (;;)
    {
        connfd = accept(listenfd, ...) ； // 接收一个客户端的连接

        if (fork() == 0)
        {
            // 启动一个子进程去处理客户端连接
            close(listenfd);         // 子进程中持有的是listenfd的副本，没有用到，关掉
            process_request(connfd); // 子进程中处理客户端请求
            close(connfd);           // 返回后关闭与该客户端的连接
            exit(0);                 // 子进程退出
        }
        close(connfd);  // 父进程没必要保留某个连接的文件描述符，因为子进程已经在处理了，所以关掉减少引用计数
    }
}
```

>   关于 **引用计数**：在  `Unix` 系统中，每一个文件或者套接字都有一个 引用计数，维护在文件表项中，保存着 **当前打开着的 引用该文件或套接字的描述符 的个数**。垃圾清理和资源回收只会清理引用计数值为 0 的对象。在上面的伪代码中，`socket()` 返回后使得 `listenfd` 的引用计数值变为 1，`accept()` 返回后 `connfd` 的引用计数值变为 1；`fork()` 返回后，这两个描述符在父进程和子进程中共享，子进程中多了一份拷贝，因此 `listenfd` 和 `connfd` 各自变成 2。这样一来，当第 21 行父进程关闭 `connfd` 时，只是将其引用计数值减 1，结果仍为一个大于 0 的数，所以子进程中可以继续对其进行读写操作；同样，在子进程中第 16 行，子进程中用不到父进程中的 `listenfd` ，所以将其关掉，使得 `listenfd` 的引用计数始终保持在 1，这样也方便进行资源回收。

我们详细了解一下上面伪代码的过程：

首先，客户端发起请求，服务端调用 `listen()` 后 `accept()` 之前的状态如下：

![accept() 前状态](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjnxr0519zj31h80gkaek.jpg)

`accept()` 后，连接被服务器内核接受，新的已连接套接字 `connfd` 被创建，客户端和服务端可以通过这个跨连接套接字读写数据：

![accept()被接受后](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjnxv199nvj31hc0fkdl8.jpg)

并发服务器 `fork` 出一个子进程专门处理这个客户端连接：

![fork() 之后](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjnxyfvi7hj31ll0u0wou.jpg)

此时 `listenfd` 和 `connfd` 在父进程和子进程之间进行共享，下一步，父进程关闭 `connfd` ，子进程关闭 `listenfd`，然后由子进程监控 已连接套接字`connfd`，而父进程可以继续等到接受来自其他客户端的请求：

![子进程掌管与客户端的连接](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjny17xi16j31ll0u0gva.jpg)

### 3. 从 `socket` 角度看三次握手四次挥手



## 三、`Golang` 实现



## 四、参考资料

-   [UNIX网络编程 卷1：套接字联网API（第3版）](https://book.douban.com/subject/4859464/)
-    [Linux Socket编程（不限Linux）](https://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html)
-   [揭开Socket编程的面纱](https://www.cnblogs.com/goodcandle/archive/2005/12/10/socket.html)

